import * as requests from "../inputRequests.mjs";
import * as stepGenerators from "../stepGenerators.mjs";

// super class for all inserts
export class StepRunnerInsert {
	constructor() {}
	// implemented by subclasses
	async* run(isPrediction = false) {}
	async* undo(isPrediction = false) {}

	getSteps() {
		return [];
	}
}

// Is generated by a you.may{} section in cdfScript
export class OptionalEffectSectionInsert extends StepRunnerInsert {
	constructor(player, ctx, isForced, mainBlock, thenBlock, elseBlock) {
		super();
		this.player = player;
		this.ctx = ctx;
		this.isForced = isForced;
		this.mainBlock = mainBlock;
		this.thenBlock = thenBlock;
		this.elseBlock = elseBlock;

		this.mainRunner = null;
		this.thenRunner = null;
		this.elseRunner = null;
		this.didMainBlock = false;
	}

	async* run(isPrediction = false) {
		this.mainRunner = new stepGenerators.StepRunner(() => stepGenerators.abilityFractionStepGenerator(this.mainBlock, this.ctx), this.ctx.game);
		this.mainRunner.isCost = true; // treating this like a cost means it needs to be fully possible to be done
		const optionTree = new stepGenerators.OptionTreeNode(this.ctx.game, this.mainRunner, () => true);

		if (!(await optionTree.isValid())) {
			yield* this._tryRunElseBlock(isPrediction);
			return;
		};

		// if this is possible and not mandatory, ask the player if he would like to do the optional part of the effect
		if (!this.isForced) {
			const optionalRequest = new requests.DoOptionalEffectSection(this.player, this.ctx.ability, this.mainBlock);
			if (!await optionalRequest.extractResponseValue(yield [optionalRequest])) {
				yield* this._tryRunElseBlock(isPrediction);
				return;
			};
		}

		// the player said yes, run the main optional part, restricted by the option tree, as that player
		this.mainRunner.optionTree = optionTree;
		let initialCtxPlayer = this.ctx.player;
		this.ctx.player = this.player;
		yield* this.mainRunner.run(isPrediction);
		this.ctx.player = initialCtxPlayer;
		this.didMainBlock = true;

		if (!this.thenBlock) return;
		this.thenRunner = new stepGenerators.StepRunner(() => stepGenerators.abilityFractionStepGenerator(this.thenBlock, this.ctx), this.ctx.game);
		yield* this.thenRunner.run(isPrediction);
	}

	async* _tryRunElseBlock(isPrediction) {
		if (!this.elseBlock) return;
		this.elseRunner = new stepGenerators.StepRunner(() => stepGenerators.abilityFractionStepGenerator(this.elseBlock, this.ctx), this.ctx.game);
		yield* this.elseRunner.run(isPrediction);
	}

	* undo(isPrediction = false) {
		if (this.didMainBlock) {
			if (this.thenRunner) {
				yield* this.thenRunner.undo(isPrediction);
			}
			yield* this.mainRunner.undo(isPrediction);
		} else {
			if (this.elseRunner) {
				yield* this.elseRunner.undo(isPrediction);
			}
		}
	}

	getSteps() {
		let steps = [];
		if (this.didMainBlock) {
			steps = steps.concat(this.mainRunner.getSteps());
			if (this.thenRunner) {
				steps = steps.concat(this.thenRunner.getSteps());
			}
		} else {
			if (this.elseRunner) {
				steps = steps.concat(this.elseRunner.getSteps());
			}
		}
		return steps;
	}
}