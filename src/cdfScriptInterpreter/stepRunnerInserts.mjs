import * as requests from "../inputRequests.mjs";
import * as stepGenerators from "../stepGenerators.mjs";

// super class for all inserts
export class StepRunnerInsert {
	constructor() {}
	// implemented by subclasses
	async* run(isPrediction = false) {}
	async* undo(isPrediction = false) {}

	getSteps() {
		return [];
	}
}

// Is generated by a you.may{} section in cdfScript
export class OptionalEffectSectionInsert extends StepRunnerInsert {
	constructor(player, ctx, rootNode) {
		super();
		this.player = player;
		this.ctx = ctx;
		this.rootNode = rootNode;
		this.stepRunner = null;
	}

	async* run(isPrediction = false) {
		this.stepRunner = new stepGenerators.StepRunner(() => stepGenerators.abilityFractionStepGenerator(this.rootNode, this.ctx), this.ctx.game);
		this.stepRunner.isCost = true; // treating this like a cost means it needs to be fully possible to be done
		const optionTree = new stepGenerators.OptionTreeNode(this.ctx.game, this.stepRunner, () => true);

		if (!(await optionTree.isValid())) return;

		// if this is possible, ask the player if he would like to do the optional part of the effect
		const optionalRequest = new requests.DoOptionalEffectSection(this.player, this.ctx.ability, this.rootNode);
		if (!optionalRequest.extractResponseValue(yield [optionalRequest])) return;

		// the player said yes, run the optional part, restricted by the option tree
		this.stepRunner.optionTree = optionTree;
		yield* this.stepRunner.run(isPrediction);
	}

	async* undo(isPrediction = false) {
		return yield* this.stepRunner.undo(isPrediction);
	}

	getSteps() {
		return this.stepRunner.getSteps();
	}
}